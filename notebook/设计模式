开闭原则：开放拓展，关闭修改（可以优化扩展，但不可以修改原有的代码）

一.创建类模式（5种）

1.普通工厂模式

（1）使用：提供一个公用接口（模板），提供该接口的实现类（产品），最后通过一个工厂类去提供返回产品的方法
（2）缺点：拓展性不好，每当要添加新的产品时，就需要修改原有的工厂类，不符合设计模式中的‘开闭’原则
（3）备注：普通工厂模式中运用最多的是静态工厂模式


2.抽象工厂模式

（1）使用：提供一个由产品类实现的公共接口，提供一个由工厂类实现的工厂接口，每一个工厂创建一个产品。
（2）优点：想对于普通工厂模式，抽象工厂模式的扩展性更好，增加新的功能时，只需要添加一个产品类和一个产品工厂类即可。无需对
	   原有的代码进行任何的修改


3.单例模式

（1）使用：A.提供私有化静态属性，默认值为该对象的实例（目的是保证该对象全局唯一）
	   B.私有化构造方法 （防止被其他类实例化）
	   C.对外提供一个公开静态的方法，返回该对象的唯一实例


4.建造者模式

（1）备注：建造者模式与抽象工厂模式类似，只不过抽象工厂模式是一次生产出一个对象，而建造者模式是一次性生产出多个对象


5.原型模式

（1）使用：原型模式就是通过克隆的方式来复制创建对象的过程，实现cloneable接口



二、结构型模式

1.适配器模式
 
  （1）类的适配器模式：当希望将一个类转换成满足另一个接口的类时，使用该适配器，创建一个新类，继承原有的类，并实现新的接口
  （2）对象的适配器模式：当希望将一个对象转成满足另一个接口的对象时，可以创建一个Wrapper类，持有原来类的一个实例，实现新的接口，在Wrapper类中调用实例的方法即可
  （3）接口的适配器模式：当不希望一个类实现接口的所有方法时，可以创建一个抽象类Wrapper，实现所有的方法，写别的类的时候，继承该抽象类，并重写需要用到的方法


2.装饰模式

（1）优点：装饰模式可以动态的给一个对象增加功能，而且还能动态撤销，继承无法做到这一点，继承的功能是静态的，不能动态增删
（2）缺点：会产生过多相似的对象，不易排错


3.代理模式

（1）使用场景：如果已有的方法在使用的时候需要对原来的方法进行改进，此时有两种办法：

	A.修改原来的方法来适应，这样违反‘开闭原则’
	B.就是采用一个代理类调用原来的方法，并且对产生的结果进行控制，这种方法就是代理模式

（2）优点：使用代理模式，可以将功能划分的更加清晰，有助于后期维护
（3）代理模式和装饰模式的区别：代理模式主要用于对对象的访问，而装饰模式更加注重对对象的修改。代理模式中，通常在代理类创建一个新的实例，而装饰模式中通常把原始对象作为一个参数传给装饰着的构造器	
