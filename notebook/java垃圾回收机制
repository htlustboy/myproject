一、java垃圾回收机制

1.标记-清除算法（Mark-Sweep）

内容：将整个垃圾回收分为两个过程，一个是标记阶段，一个是清除阶段，标记阶段是标记出所有需要被回收的对象，清除阶段就是释放被标记的对象所占用的空间。
缺点：由于对象不一定是连续的，所以会产生很多内存碎片，导致后续过程中为大对象分配内存而无法找到足够的空间。

2.复制算法（Copying）

内容：将内存按照容量分为两块相同的大小的部分，每次只是用一块，当一块内存使用完了，就把其中还存活的对象复制到另一块中，然后清空该部分内存。
缺点：虽然解决了内存碎片的问题，但是会导致成本增加，可用内存减少。

3.标记-整理算法（Mark-Compact）

内容：该算法和标记-清除算法大致，标记阶段相同，但清除阶段前，会将存活的对象全部移动到内存的一端，然后清理掉边界以外的内存。
优点：节约了内存，同时解决了内存碎片的问题

4.分代回收算法（Generational Collection）

内容：分代回收算法是目前大部分JVM的主流垃圾回收采用的算法。它的核心是根据对象存活的生命周期将内存分为若干个不同的区域，一般情况下是分为老年代和新生代，老年代
	 的特点是每次只有很少一部分被回收，新生代的特点是每次都有大量的对象被垃圾回收，那么就可以根据不同的特点采取不同的收集算法。      目前大部分新生代都采用copying
	 回收算法，将新生代划分为一块较大的Eden和两块较小的Survivor空间，每次只使用Eden和一块Survivor空间，当进行回收时，将还存活的对象复制到另一块Survivor
	 中，然后清理掉Eden和使用过的Survivor空间。       而老年代每次只有很少的对象被回收，所以采用Mark-Compacrt(标记-整理)算法。